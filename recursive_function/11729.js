const fs = require("fs");
const N = parseInt(fs.readFileSync("/dev/stdin").toString());

const moves = [];

/**
 * 하노이 탑 재귀 함수
 * @param {number} n - 원판의 개수
 * @param {number} start - 시작 기둥
 * @param {number} to - 목표 기둥
 * @param {number} via - 보조 기둥
 */
function hanoi(n, start, to, via) {
  // 종료 조건: 원판이 1개일 때
  if (n === 1) {
    moves.push(`${start} ${to}`);
    return;
  }

  // 1. n-1개의 원판을 시작 기둥(start)에서 보조 기둥(via)으로 옮깁니다.
  hanoi(n - 1, start, via, to);

  // 2. 가장 큰 원판(n번째)을 시작 기둥(start)에서 목표 기둥(to)으로 옮깁니다.
  moves.push(`${start} ${to}`);

  // 3. 보조 기둥(via)에 있던 n-1개의 원판을 목표 기둥(to)으로 옮깁니다.
  hanoi(n - 1, via, to, start);
}

// 총 이동 횟수는 2^N - 1 입니다.
// N이 클 경우 숫자가 매우 커질 수 있으므로 BigInt를 사용합니다.
const count = BigInt(2) ** BigInt(N) - BigInt(1);

hanoi(N, 1, 3, 2);

console.log(count.toString());
console.log(moves.join("\n"));

/**
 * 재귀적 사고를 위한 복습 및 훈련법 🧠

1. 문제의 핵심 로직을 '나의 언어'로 설명하기
코드를 보지 말고, N=3인 하노이 탑 문제를 A4용지나 화이트보드에 직접 풀어보세요. 이때 컴퓨터처럼 생각하는 게 아니라, 큰 덩어리로 생각하는 겁니다.

"일단 원판 3개를 1번에서 3번으로 옮기려면... 제일 큰 3번 원판이 3번으로 가야 해."

"그러려면 방해되는 1, 2번 원판이 2번 기둥으로 치워져 있어야겠네." (이것이 첫 번째 재귀 호출: hanoi(2, 1, 2))

"자, 이제 1, 2번이 2번으로 갔다고 '치고', 3번 원판을 1번에서 3번으로 옮기자." (이것이 기본 작업: 1 -> 3 출력)

"마지막으로 2번에 있는 1, 2번 원판을 다시 3번으로 옮기면 되겠구나." (이것이 두 번째 재귀 호출: hanoi(2, 2, 3))

이렇게 가장 큰 문제(N)를 해결하기 위해, 더 작은 문제(N-1)를 해결해야 한다는 점을 명확하게 인지하는 것이 재귀의 첫걸음입니다. 이 과정을 말로 설명할 수 있을 때까지 반복해보세요.



2. 재귀 함수의 '계약서'를 작성하고 믿기 (Leap of Faith)
재귀 함수를 짤 때 모든 과정을 머릿속으로 따라가려고 하면 스택이 터져버립니다. 🤯 대신 함수가 **'이러한 입력을 주면, 이러한 결과를 돌려줄 것'**이라고 굳게 믿어야 합니다.これを 'Recursive Leap of Faith (재귀적 믿음의 도약)'라고 부릅니다.

hanoi(n, start, to, via) 함수와 계약서를 쓴다고 상상해보세요.

계약 내용: "이 함수는 n개의 원판을 start 기둥에서 to 기둥으로, via 기둥을 거쳐서 옮기는 방법을 모두 출력해준다."

이 계약을 믿는다면, hanoi(n - 1, start, via, to)를 호출할 때 그 내부에서 무슨 일이 일어나는지 일일이 생각할 필요가 없습니다. 그냥 "아, n-1개를 시작점에서 보조 기둥으로 옮겨주겠구나" 하고 믿고 맡기는 겁니다. 이 믿음이 있어야 큰 그림을 설계할 수 있습니다.



3. 두 가지 핵심 질문에 답하기
모든 재귀 문제는 이 두 가지 질문으로 귀결됩니다.

"언제 멈춰야 하는가?" (Base Case / 종료 조건)

문제가 더 이상 쪼개질 수 없는 가장 단순한 상태는 무엇일까요?

하노이 탑에서는 원판이 1개일 때입니다. 그냥 시작점에서 목표점으로 옮기면 끝이죠. if (n === 1) 코드가 바로 그 역할을 합니다.

"문제를 어떻게 작게 만들 것인가?" (Recursive Case / 재귀 단계)

N일 때의 문제를 어떻게 N-1 (또는 더 작은) 문제로 표현할 수 있을까요?

위 1번에서 설명한 "나의 언어"로 풀어본 과정이 바로 재귀 단계에 해당합니다.



4. 프론트엔드 개발 경험과 연결하기
프론트엔드 개발자로서 이미 재귀적인 구조에 익숙하실 겁니다.

React 컴포넌트 트리: 메뉴 컴포넌트가 하위 메뉴 아이템들을 렌더링하고, 그 메뉴 아이템이 또 다른 하위 메뉴를 렌더링하는 구조는 재귀적입니다.

DOM 트리 탐색: 특정 노드에서 시작해서 모든 자식 노드를 순회하는 로직을 짤 때 재귀가 유용합니다.

JSON 데이터 파싱: 중첩된 객체나 배열 구조의 데이터를 다룰 때 재귀 함수를 사용하면 코드가 매우 간결해집니다.

"내가 다루는 데이터나 컴포넌트 구조에서 반복되는 패턴이 있는가?"를 생각해보는 것이 재귀적 사고 훈련에 도움이 됩니다.
 */
